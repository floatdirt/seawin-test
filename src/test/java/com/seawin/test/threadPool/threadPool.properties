
https://www.jianshu.com/p/210eab345423


ThreadPoolExecutor的策略
上面介绍参数的时候其实已经说到了ThreadPoolExecutor执行的策略，这里给总结一下，当一个任务被添加进线程池时：

1、线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务
2、线程数量达到了corePools，则将任务移入队列等待
3、队列已满，新建线程(非核心线程)执行任务
4、队列已满，总线程数又达到了maximumPoolSize，就会由上面那位星期天(RejectedExecutionHandler)抛出异常

CachedThreadPool()
可缓存线程池：
线程数无限制
有空闲线程则复用空闲线程，若无空闲线程则新建线程
一定程序减少频繁创建/销毁线程，减少系统开销

FixedThreadPool()
定长线程池：
可控制线程最大并发数（同时执行的线程数）
超出的线程会在队列中等待

ScheduledThreadPool()
定长线程池：
支持定时及周期性任务执行。

SingleThreadExecutor()
单线程化的线程池：
有且仅有一个工作线程执行任务
所有任务按照指定顺序执行，即遵循队列的入队出队规则


/**
     * 新建(New)、就绪（Runnable）、运行（Running）、 阻塞(Blocked)和死亡(Dead)5种状态
     * 
     * 
     * 
     */
    /**
     * (1)生命周期的五种状态

                        新建（new Thread）
                        当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
                        例如：Thread t1=new Thread();
                        
                        就绪（runnable）
                        线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();
                        
                        运行（running）
                        线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。
                        
                        死亡（dead）
                        当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。
                        
                        自然终止：正常运行run()方法后终止
                        
                        异常终止：调用stop()方法让一个线程终止运行
                        
                        堵塞（blocked）
                        由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。
                        
                        正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。
                        
                        正在等待：调用wait()方法。（调用notify()方法回到就绪状态）
                        
                        被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）
     */



 	(1)生命周期的五种状态

                        新建（new Thread）
                        当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。
                        例如：Thread t1=new Thread();
                        
                        就绪（runnable）
                        线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();
                        
                        运行（running）
                        线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。
                        
                        死亡（dead）
                        当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。
                        
                        自然终止：正常运行run()方法后终止
                        
                        异常终止：调用stop()方法让一个线程终止运行
                        
                        堵塞（blocked）
                        由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。
                        
                        正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。
                        
                        正在等待：调用wait()方法。（调用notify()方法回到就绪状态）
                        
                        被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）